input {
    beats {
        port => 5045
    }
}
filter {
    if "Mailbox" in [log][file][path] {
    grok {
        match   => [ "message", "%{SYSLOGBASE} %{GREEDYDATA:message}" ]
        overwrite => [ "message", "timestamp" ]
    }
    if "_grokparsefailure" in [tags] {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match   => [ "message", "%{TIMESTAMP_ISO8601:timestamp}\s%{LOGLEVEL:log_level}\s\s?\[%{DATA:component}\] \[%{DATA:account_info}\] %{GREEDYDATA:message}" ]
            overwrite => [ "message", "timestamp" ]
            remove_tag => [ "_grokparsefailure", "beats_input_codec_plain_applied" ]
            add_tag => ["_mailboxd_success"]
            tag_on_failure => ["_mailboxd_failed"]
        }
    }
    date {
        match => [ "timestamp", "MMM dd HH:mm:ss",
                              "MMM  d HH:mm:ss", "ISO8601" ]
        timezone => "Etc/GMT+3"
    }
###Zimbra_account_info
    if "_mailboxd_success" in [tags] {
        kv {
            allow_duplicate_values => false
            field_split => ";?"
            source => "account_info"
            prefix => "zimbra_account_"
            add_tag => ["_zimbra_account_kv_success"]
            tag_on_failure => ["_zimbra_account_kv_failed"]
        }
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match   => [ "message", "%{DATA:zimbra_module} - %{GREEDYDATA:message}" ]
            overwrite => [ "message" ]
            add_tag => ["_zimbra_module_success"]
            tag_on_failure => ["_zimbra_module_failed"]
        }
    }
    if [zimbra_account_ua] {
        useragent {
            source => "zimbra_account_ua"
            prefix => "zimbra_account_ua_"
        }
    }
    if [component] {
        grok {
                patterns_dir    => "/usr/share/logstash/config/patterns"
                match           => [ "component" , "%{DATA:zimbra_component}-%{INT:zimbra_component_thread_id}(:%{GREEDYDATA:zimbra_component_url})?" ]
                add_tag         => "_zimbra_component_success"
                tag_on_failure  => "_zimbra_component_failed"
        }
        if "_zimbra_component_failed" in [tags] {
            mutate {
                rename => ["component", "zimbra_component" ]
                add_tag => "_zimbra_component_success"
                remove_tag => "_zimbra_component_failed"
            }
        }
    }
####Zimbra_module_info
    if [zimbra_module] == "smime" {
        grok {
            patterns_dir    => "/usr/share/logstash/config/patterns"
            match           => [ "message" , "%{DATA:zimbra_action_feature}: %{GREEDYDATA:message}" ]
            overwrite       => [ "message" ]
            add_tag         => "_zimbra_action_success"
            tag_on_failure  => "_zimbra_action_failed"
        }
        if "feature not enabled" in [message] {
            grok {
                patterns_dir    => "/usr/share/logstash/config/patterns"
                    match           => [ "message" , "%{DATA} feature not enabled( %{DATA})? (for|on) account( |=)%{NOTSPACE:zimbra_action_account}" ]
                    add_tag         => "_zimbra_feature_message_success"
                    tag_on_failure  => "_zimbra_feature_message_failed"
                    add_field       => [ "zimbra_status", "feature not enabled" ]
                }
            }
    }
    else if [zimbra_module] == "soap" {
        grok {
            patterns_dir    => "/usr/share/logstash/config/patterns"
            match           => [ "message" , "%{DATA:zimbra_action_feature}: %{DATA:zimbra_action_feature_request} reason: %{GREEDYDATA:zimbra_action_reason}" ]
            add_tag         => "_zimbra_action_success"
            tag_on_failure  => "_zimbra_action_failed"
        }
        if "_zimbra_action_success" in [tags] {
            if [zimbra_action_feature_request] {
                mutate {
                    gsub => [ "zimbra_action_feature_request","authAcct name","authAcct_name" ]
                }
                kv {
                    allow_duplicate_values => false
                    source => "zimbra_action_feature_request"
                    prefix => "zimbra_action_feature_request_"
                    include_brackets => true
                    add_tag => ["_zimbra_action_request_kv_success"]
                    tag_on_failure  => "_zimbra_action_request_kv_failed"
                }
                kv {
                    allow_duplicate_values => false
                    source => "zimbra_action_reason"
                    prefix => "zimbra_action_feature_reason_"
                    include_brackets => true
                    add_tag => ["_zimbra_action_reason_kv_success"]
                    tag_on_failure  => "_zimbra_action_reason_kv_failed"
                }
            }
            
        }
        else {
            grok {
                patterns_dir    => "/usr/share/logstash/config/patterns"
                    match           => [ "message" , "(%{DATA:zimbra_action_feature} elapsed=%{NUMBER:zimbra_action_elapsed})|(%{GREEDYDATA:zimbra_action_feature})" ]
                    add_tag         => "_zimbra_elapsed_success"
                    tag_on_failure  => "_zimbra_elapsed_failed"
                    remove_tag       => [ "_zimbra_action_failed" ]
                }
            }
    }
    else if [zimbra_module] == "mailop" {
        if "Moving VirtualConversation" in [message] or "Moving Conversation" in [message] {
            grok {
                patterns_dir    => "/usr/share/logstash/config/patterns"
                match           => [ "message" , "%{DATA:zimbra_action_feature} \(id=%{NUMBER}\) to Folder %{DATA:zimbra_action_message_folderName} \(id=%{NUMBER:DATA:zimbra_action_message_folderId}\)\. %{DATA}: %{DATA:zimbra_action_message_id}\." ]
                add_tag         => "_zimbra_action_moving_conv_success"
                tag_on_failure  => "_zimbra_action_moving_conv_failed"
            }
            mutate {
                split => ["zimbra_action_message_id",","]
            }
        }
        else if "Adding Tag" in [message] {
            grok {
                patterns_dir    => "/usr/share/logstash/config/patterns"
                match           => [ "message" , "%{ADDED_TAG:zimbra_action_feature} %{DATA:zimbra_action_tag}: id=%{DATA:zimbra_action_tagId}\." ]
                add_tag         => "_zimbra_action_addtag_success"
                tag_on_failure  => "_zimbra_action_addtag_failed"
            }
        }
        else if "moving Folder" in [message] {
            grok {
                patterns_dir    => "/usr/share/logstash/config/patterns"
                match           => [ "message" , "%{MOVING_FOLDER:zimbra_action_feature} %{DATA:zimbra_action_folderName} \(id=%{NUMBER:zimbra_action_folderId}\) to Folder %{DATA:zimbra_action_folderName_destination} \(id=%{NUMBER:zimbra_action_folderId_destination}\)" ]
                add_tag         => "_zimbra_action_movefolder_success"
                tag_on_failure  => "_zimbra_action_movefolder_failed"
            }
        }
        else if "Deleting Contact" in [message] {
            grok {
                patterns_dir    => "/usr/share/logstash/config/patterns"
                match           => [ "message" , "%{DELETE_CONTACT:zimbra_action_feature} %{DATA:zimbra_action_contact} \(id=%{NUMBER:zimbra_action_contactId}\)\." ]
                add_tag         => "_zimbra_action_deleting_cont_success"
                tag_on_failure  => "_zimbra_action_deleting_cont_failed"
            }
        }
        else if "moving contact" in [message] or "Moving Conversation" in [message] or "moving Contact" in [message] {
            grok {
                patterns_dir    => "/usr/share/logstash/config/patterns"
                match           => [ "message" , "%{MOVING_CONTACT:zimbra_action_feature} %{DATA:zimbra_action_contact} \(id=%{NUMBER:zimbra_action_contactId}\) to Folder %{DATA:zimbra_action_folderName} \(id=%{NUMBER:zimbra_action_folderId}\)" ]
                add_tag         => "_zimbra_action_moving_cont_success"
                tag_on_failure  => "_zimbra_action_moving_cont_failed"
            }
        }
        else if "Deleting Folder" in [message] {
            grok {
                patterns_dir    => "/usr/share/logstash/config/patterns"
                match           => [ "message" , "%{DELETE_FOLDER:zimbra_action_feature} %{DATA:zimbra_action_folderName} \(id=%{DATA:zimbra_action_folderId}\)\." ]
                add_tag         => "_zimbra_action_delete_folder_success"
                tag_on_failure  => "_zimbra_action_delete_folder_failed"
            }
        }
        else {
            grok {
                patterns_dir    => "/usr/share/logstash/config/patterns"
                match           => [ "message" , "%{DATA:zimbra_action_feature}: %{GREEDYDATA:zimbra_action_message}" ]
                add_tag         => "_zimbra_action_success"
                tag_on_failure  => "_zimbra_action_failed"
            }
            if "_zimbra_action_success" in [tags] {
                kv {
                    allow_duplicate_values => false
                    source => "zimbra_action_message"
                    field_split_pattern => ", "
                    prefix => "zimbra_action_message_"
                    include_brackets => true
                    add_tag => ["_zimbra_action_message_kv_success"]
                    tag_on_failure  => "_zimbra_action_message_kv_failed"
                }
                if [zimbra_action_message_folderName] {
                    grok {
                        patterns_dir    => "/usr/share/logstash/config/patterns"
                        match           => [ "zimbra_action_message_folderName" , "%{DATA:zimbra_action_message_folderName} acct=%{DATA:zimbra_action_message_acct}\.|%{GREEDYDATA:zimbra_action_message_folderName}" ]
                        overwrite       => [ "zimbra_action_message_folderName" ]
                        add_tag         => "_zimbra_action_folder_success"
                        tag_on_failure  => "_zimbra_action_folder_failed"
                    }
                }
                if "Deleting" in [message] {
                    grok {
                        patterns_dir    => "/usr/share/logstash/config/patterns"
                        match           => [ "message" , "%{DATA}: %{DATA:zimbra_action_message_id}\." ]
                        add_tag         => "_zimbra_action_deleting_success"
                        tag_on_failure  => "_zimbra_action_deleting_failed"
                    }
                    mutate {
                        split => ["zimbra_action_message_id",","]
                        remove_tag => "_zimbra_action_failed"
                    }
                }
                else if "adding contact" in [zimbra_action_feature] {
                    grok {
                        patterns_dir    => "/usr/share/logstash/config/patterns"
                        match           => [ "zimbra_action_feature" , "%{ADDED_CONTACT:zimbra_action_feature} %{GREEDYDATA:zimbra_action_addedContact}" ]
                        overwrite       => [ "zimbra_action_feature" ]
                        add_tag         => "_zimbra_action_add_contact_success"
                        tag_on_failure  => "_zimbra_action_add_contact_failed"
                    }
                }
                else if "modifying contact" in [zimbra_action_feature] {
                    grok {
                        patterns_dir    => "/usr/share/logstash/config/patterns"
                        match           => [ "zimbra_action_feature" , "%{MODIFYING_CONTACT:zimbra_action_feature} %{GREEDYDATA:zimbra_action_contact}" ]
                        overwrite       => [ "zimbra_action_feature" ]
                        add_tag         => "_zimbra_action_mod_contact_success"
                        tag_on_failure  => "_zimbra_action_mod_contact_failed"
                    }
                }
                else if "Copying Message" in [zimbra_action_feature] {
                    grok {
                    patterns_dir    => "/usr/share/logstash/config/patterns"
                    match           => [ "zimbra_action_feature" , "%{DATA:zimbra_action_feature} \(id=%{NUMBER:zimbra_action_copyingId}\)" ]
                    overwrite       => [ "zimbra_action_feature" ]
                    add_tag         => "_zimbra_action_success"
                    tag_on_failure  => "_zimbra_action_failed"
                    }
                }
            }
            else {
                if "moving" in [message] {
                    grok {
                        patterns_dir    => "/usr/share/logstash/config/patterns"
                        match           => [ "message" , "%{DATA:zimbra_action_feature} \(id=%{NUMBER:zimbra_action_message_id}\) to Folder %{DATA:zimbra_action_message_folderName} \(id=%{NUMBER:DATA:zimbra_action_message_folderId}\)" ]
                        add_tag         => "_zimbra_action_moving_success"
                        tag_on_failure  => "_zimbra_action_moving_failed"
                    }
                    mutate {
                        remove_tag => "_zimbra_action_failed"
                    }
                }
                if "Deleting" in [message] {
                    grok {
                        patterns_dir    => "/usr/share/logstash/config/patterns"
                        match           => [ "message" , "%{DATA:zimbra_action_feature} \(id=%{NUMBER:zimbra_action_message_id}\)\." ]
                        add_tag         => "_zimbra_action_deleting_success"
                        tag_on_failure  => "_zimbra_action_deleting_failed"
                    }
                    mutate {
                        split => ["zimbra_action_message_id",","]
                        remove_tag => "_zimbra_action_failed"
                    }
                }
            }
        }
        mutate {
            lowercase => [ "zimbra_action_feature" ]
        }
        dissect {
            mapping => {
                "zimbra_action_feature" => "%{zimbra_action} %{zimbra_action_feature}"
              }
        }
        mutate {
            remove_field => ["component", "account_info", "zimbra_action_feature_request", "zimbra_action_feature_reason", "zimbra_action_message"]
            gsub => [ 
                    "zimbra_action_feature", "_", "",
                    "zimbra_action_feature", "contacts", "contact",
                    "zimbra_action_feature", "conversations", "conversation",
                    "zimbra_action_feature", "messages", "message",
                    "zimbra_action_feature", "appointments", "appointment",
                    "zimbra_action_feature", "tasks", "task",
                    "zimbra_action_feature", "appointments", "appointment",
                    "zimbra_action_feature", "folders", "folder"
                ]
        }
    }
    else if [zimbra_module] == "pop" {
        if [message] == "connected" or [message] == "quit from client" {
            mutate {
                add_field => [ "zimbra_status", "%{message}" ]
            }
        }
        else if "identified" in [message] {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match   => [ "message", "%{WORD:zimbra_action_feature} client %{DATA:zimbra_status} as: %{IPORHOST:zimbra_action_srcclient}" ]
                add_tag => ["_zimbra_action_id_success"]
                tag_on_failure  => "_zimbra_action_id_failed"
            }
        }
        else if "authenticated" in [message] {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match   => [ "message", "user %{DATA:zimbra_action_srcusername} %{DATA:zimbra_status}, mechanism=%{GREEDYDATA:zimbra_action_mechanism}" ]
                add_tag => ["_zimbra_action_id_success"]
                tag_on_failure  => "_zimbra_action_id_failed"
            }
        }
        else {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match   => [ "message", "%{WORD:zimbra_status} elapsed=%{NUMBER:zimbra_elapsed}" ]
                add_tag => ["_zimbra_action_elapsed_success"]
                tag_on_failure  => "_zimbra_action_elapsed_failed"
            }
        }
    }
    else if [zimbra_module] == "imap" {
        if "authenticated" in [message] {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match   => [ "message", "user %{DATA:zimbra_action_srcusername} %{DATA:zimbra_status}, mechanism=%{GREEDYDATA:zimbra_action_mechanism}" ]
                add_tag => ["_zimbra_action_id_success"]
                tag_on_failure  => "_zimbra_action_id_failed"
            }
        }
        else if "elapsed" in [message] {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match   => [ "message", "%{DATA:zimbra_status} elapsed=%{NUMBER:zimbra_elapsed}" ]
                add_tag => ["_zimbra_action_elapsed_success"]
                tag_on_failure  => "_zimbra_action_elapsed_failed"
            }
        }
        else if "search is" in [message] {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match   => [ "message", "\[ %{DATA}: (%{DATA:zimbra_search} )?in:\"%{DATA:zimbra_searchFolder}\" \(item:%{DATA:zimbra_searchItem} date:%{DATA:zimbra_searchPeriod}\) \]" ]
                add_tag => ["_zimbra_action_elapsed_success"]
                tag_on_failure  => "_zimbra_action_elapsed_failed"
            }
        }
        else if "authentication failed" in [message] or "dropping connection" in [message] {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match   => [ "message", "%{DATA:zimbra_status} for (user )?(\[)?%{DATA:zimbra_account_name}(\])? \(%{DATA:zimbra_action_reason}\)" ]
                add_tag => ["_zimbra_action_reas_success"]
                tag_on_failure  => "_zimbra_action_reas_failed"
            }
        }
        else if "selected folder" in [message] {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match   => [ "message", "%{TWOWORD:zimbra_status} %{GREEDYDATA:zimbra_action_message_folderName}" ]
                add_tag => ["_zimbra_action_reas_success"]
                tag_on_failure  => "_zimbra_action_reas_failed"
            }
        }
        else if "flagged" in [message] {
            dissect {
                mapping => {
                    "message" => "IMAP client has %{zimbra_status} the item with id %{zimbra_itemId} to be %{zimbra_action} %{zimbra_action_feature}"
                }
            }
        }
    }
    else if [zimbra_module] == "SoapEngine" {
        if "multiline" not in [log][flags] {
            dissect {
                mapping => {
                    "message" => "%{zimbra_action_request}: %{zimbra_action_reason}"
                }
            }
            if "sub-request" in [zimbra_action_request] {
                grok {
                    patterns_dir   => "/usr/share/logstash/config/patterns"
                    match   => [ "message", "%{DATA:zimbra_action_request} \[%{DATA:zimbra_action_soapRequest}\] contains %{NUMBER:zimbra_action_numSubrequest} %{GREEDYDATA}" ]
                    overwrite => "zimbra_action_request"
                    add_tag => ["_zimbra_action_subrequest_success"]
                    tag_on_failure  => "_zimbra_action_subrequest_failed"
                }
                mutate {
                    rename => ["zimbra_action_reason", "zimbra_action_subRequest"]
                    split => ["zimbra_action_subRequest",","]
                }
            }
            else if [zimbra_action_request] == "handler exception" {
                grok {
                    patterns_dir   => "/usr/share/logstash/config/patterns"
                    match   => [ "zimbra_action_reason", "%{DATA:zimbra_status} for \[%{DATA}\], %{GREEDYDATA:zimbra_action_reason}" ]
                    overwrite => "zimbra_action_reason"
                    add_tag => ["_zimbra_action_reas_success"]
                    tag_on_failure  => "_zimbra_action_reas_failed"
                }
            }
        }
        else {
        }
    }
    else if [zimbra_module] == "lmtp" {
        if "Not delivering" in [message] {
            dissect {
                mapping => [ "message", "%{zimbra_status} message with %{zimbra_action_reason} <%{zimbra_action_message_Message-ID}>"]
                add_field => ["zimbra_status_feature", "message"]
            }
        }
        else if "disconnected" in [message] {
            dissect {
                mapping => [ "message", "%{zimbra_status} without quit" ]
            }
        }
        else if "accepted" in [message] {
            dissect {
                mapping => [ "message", "%{zimbra_status} and %{+zimbra_status} message from=%{zimbra_action_from},to=%{zimbra_action_to}: %{zimbra_action_reason}" ]
            }
        }
        else {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match   => [ "message", "%{WORD:zimbra_status} %{WORD:zimbra_status_feature}: %{GREEDYDATA:zimbra_lmtp}" ]
                add_tag => ["_zimbra_lmtp_success"]
                tag_on_failure  => "_zimbra_lmtp_failed"
            }
            kv {
                allow_duplicate_values => false
                field_split => ", "
                source => "zimbra_lmtp"
                prefix => "zimbra_action_message_"
                include_brackets => true
                add_tag => ["_zimbra_lmtp_kv_success"]
                tag_on_failure => ["_zimbra_lmtp_kv_failed"]
            }
            mutate {
                remove_field => [ "zimbra_lmtp" ]
            }
        }
    }
    else if [zimbra_module] == "misc" {
        if "multiline" not in [log][flags] {
            if "Access from" in [message] {
                dissect {
                    mapping => [ "message","Access from IP %{zimbra_action_srcIp} %{zimbra_status}, for %{zimbra_action_reason}." ]
                }
            }
            else if "SpamReport" in [message] {
                grok {
                    patterns_dir   => "/usr/share/logstash/config/patterns"
                    match   => [ "message", "%{WORD:zimbra_status} %{WORD:zimbra_status_feature}{%{DATA:zimbra_misc}}" ]
                    add_tag => ["_zimbra_misc_success"]
                    tag_on_failure  => "_zimbra_misc_failed"
                }  
                kv {
                    allow_duplicate_values => false
                    field_split => ", "
                    source => "zimbra_misc"
                    prefix => "zimbra_action_message_"
                    include_brackets => true
                    add_tag => ["_zimbra_misc_kv_success"]
                    tag_on_failure => ["_zimbra_misc_kv_failed"]
                }
                mutate {
                    remove_field => [ "zimbra_misc" ]
                }
            }
            else if "Invalid login filter" in [message] {
                dissect {
                    mapping => ["message", "%{zimbra_status},%{zimbra_action_reason}"]
                }
            }
            else if "delegated access" in [message] {
                grok {
                    patterns_dir   => "/usr/share/logstash/config/patterns"
                    match   => [ "message", "%{WORD:zimbra_status} %{WORD:zimbra_status_feature}: %{GREEDYDATA:zimbra_misc}" ]
                    add_tag => ["_zimbra_misc_success"]
                    tag_on_failure  => "_zimbra_misc_failed"
                }
                mutate {
                    gsub => [ 
                        "zimbra_misc", "g a", "g_a",
                        "zimbra_misc", "d a", "d_a",
                        "zimbra_misc", "t a", "t_a"
                    ]
                }
                kv {
                    allow_duplicate_values => false
                    field_split => ", "
                    source => "zimbra_misc"
                    prefix => "zimbra_action_message_"
                    include_brackets => true
                    add_tag => ["_zimbra_misc_kv_success"]
                    tag_on_failure => ["_zimbra_misc_kv_failed"]
                }
                mutate {
                    remove_field => [ "zimbra_misc" ]
                }
            }
            else if "Exceeded" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_action_reason}. %{zimbra_status} "]
                }
            }
        }
    }
    else if [zimbra_module] == "account" {
        if "multiline" not in [log][flags] {
            if "not enabled" in [message] {
                dissect {
                    mapping => ["message", "%{zimbra_status} - %{zimbra_action_feature} not enabled for %{zimbra_srcaccount}"]
                    add_field => [ "zimbra_action_reason", "not enabled"]
                }
            }
            else if "such account" in [message] {
                dissect {
                    mapping => ["message", "%{zimbra_status} for %{zimbra_srcaccount} (%{zimbra_action_reason})"]
                }                
            }
        }
    }
    else if [zimbra_module] == "mailbox" {
        if "multiline" not in [log][flags] {
            if "outofoffice not sent" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_status_feature} not sent (%{zimbra_action_reason}) mid=%{zimbra_account_mid} rcpt='%{zimbra_account_rcpt}'" ]
                    add_field => [ "zimbra_status", "not sent" ]
                }
            }
            else if "outofoffice sent" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_status_feature} sent dest='%{zimbra_account_dest}' rcpt='%{zimbra_account_rcpt}' mid=%{zimbra_account_mid}" ]
                    add_field => [ "zimbra_status", "sent" ]
                }
            }
            else if "tombstones" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_status} %{zimbra_action_number} tombstones dated before %{zimbra_action_before}." ]
                }
            }
            else if "bulk" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_status} message1 bulk delete." ]
                }
            }
            else if "no account" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_status} in directory for %{zimbra_account_mailbox} (was expecting %{zimbra_accountId})" ]
                }
            }
            else if "deleting folder" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_status} %{zimbra_status_feature} id=%{zimbra_status_id},path=%{zimbra_status_folder}" ]
                }
            }
            else if "uploadId" in [message] {
                dissect {
                    mapping => ["message","uploadId=%{zimbra_action_uploadId}" ]
                }
            }
            else if "merging" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_action} %{zimbra_action_feature} %{zimbra_action_messageId} for %{zimbra_action_reason}" ]
                }
            }
            else if "Disabled" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_status} '%{zimbra_action_feature}' %{drop}s %{zimbra_action_module} is %{zimbra_action_module_status}." ]
                    remove_field => [ "drop" ]
                }
            }
            else if "maintenance" in [message] {
                grok {
                    match   => [ "message", "(%{WORD:zimbra_action} %{DATA:zimbra_status} on %{DATA:zimbra_mailbox}\.)|(%{WORD:zimbra_action} %{DATA:zimbra_mailbox} under %{DATA:zimbra_status}\.)" ]
                }
            }
            else if "got blob" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_action} for %{zimbra_mailbox} (%{zimbra_mailbox_numBlobs} blobs)" ]
                }
            }
            else {
                mutate {
                    rename => ["message","zimbra_action_reason"]
                }
            }
        }
    }
    else if [zimbra_module] == "datasource" {
        if "multiline" not in [log][flags] {
            if "data source" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_status} for data source '%{zimbra_action_dataSource}'" ]
                }
            }
            else if "Requested" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_status}." ]
                }
            }
            else if "pushDelete" in [message] {
                dissect {
                    mapping => ["message","%{zimbra_action}: empty item %{zimbra_action_messageId}" ]
                }
            }
            else if "reference" in [message] {
                grok {
                    match => ["message","(%{DATA:zimbra_action} that reference %{DATA:zimbra_action_reference} in %{DATA:zimbra_action_reference}\.)|(%{DATA:zimbra_action} that reference %{DATA:zimbra_action_reference}\.)" ]
                }
            }
        }
    }
    else if [zimbra_module] == "calendar" {
        if "multiline" not in [log][flags] {
		if "DismissCalendar" in [message] {
			dissect {
				mapping => ["message","<%{zimbra_action}> id=%{zimbra_id}, at=%{zimbra_at}"]
			}
		}
		else if "Modifying" in [message] {
                        dissect {
                                mapping => ["message","%{zimbra_action}: id=%{zimbra_id}, folderId=%{zimbra_folderId}, method=%{zimbra_method}, subject=%{zimbra_subject}, UID=%{zimbra_uid}"]
                        }
		}
               else if "Adding" in [message] {
                        dissect {
                           mapping => ["message","%{zimbra_action}: id=%{zimbra_id}, Message-ID=%{zimbra_messageId}, folderId=%{zimbra_folderId}, subject=%{zimbra_subject}, UID=%{zimbra_uid}"]
                        }
                }
               else if "setCalendarItem" in [message] {
                        dissect {
                           mapping => ["message","%{zimbra_action}: id=%{zimbra_id}, folderId=%{zimbra_folderId}, subject=%{zimbra_subject}, UID=%{zimbra_uid}"]
                        }
                }
               else if "Moving" in [message] {
                        dissect {
                           mapping => ["message","%{zimbra_action}: id=%{zimbra_id}, src=%{zimbra_srcFolder}, dest=%{zimbra_destFolder}, subject=%{zimbra_subject}, UID=%{zimbra_uid}"]
                        }
                }
               else if "Deleting" in [message] {
                        dissect {
                           mapping => ["message","%{zimbra_action}: id=%{zimbra_id}, folderId=%{zimbra_folderId}, subject=%{zimbra_subject}, UID=%{zimbra_uid}"]
                        }
                }
               else if "ModifyCalendarItem" in [message] {
                        dissect {
                           mapping => ["message","<%{zimbra_action}> id=%{zimbra_id}, folderId=%{zimbra_folderId}, subject=%{zimbra_subject}, UID=%{zimbra_uid}"]
                        }
                }
               else if "CreateCalendarItem" in [message] {
                        dissect {
                           mapping => ["message","<%{zimbra_action}> folderId=%{zimbra_folderId}, subject=%{zimbra_subject}, UID=%{zimbra_uid}"]
                        }
                }
               else if "CancelCalendarItem" in [message] {
                        dissect {
                           mapping => ["message","<%{zimbra_action}> id=%{zimbra_id}, folderId=%{zimbra_folderId}, subject=%{zimbra_subject}, UID=%{zimbra_uid}, recurId=%{zimbra_recurId}"]
                        }
			if "_dissectfailure" in [tags] {
	                        dissect {
        	                   mapping => ["message","<%{zimbra_action}> id=%{zimbra_id}, folderId=%{zimbra_folderId}, subject=%{zimbra_subject}, UID=%{zimbra_uid}"]
				   remove_tag => ["_dissectfailure"]
                	        }				
			}
                }
               else if "SnoozeCalendarItemAlarm" in [message] {
                        dissect {
                           mapping => ["message","<%{zimbra_action}> id=%{zimbra_id},until=%{zimbra_until}"]
                        }
                }
               else if "SendInviteReply" in [message] {
                        dissect {
                           mapping => ["message","<%{zimbra_action}> id=%{zimbra_id}, folderId=%{zimbra_folderId}, verb=%{zimbra_verb}, notifyOrg=%{zimbra_notifyOrg}, subject=%{zimbra_subject}, UID=%{zimbra_uid}"]
                        }
                }
               else if "Processing" in [message] {
                        dissect {
                           mapping => ["message","%{zimbra_action}: attendee=%{zimbra_attendee}, partstat=%{zimbra_partstat}, id=%{zimbra_id}, folderId=%{zimbra_folderId}, subject=%{zimbra_subject}, UID=%{zimbra_uid}"]
                        }
                }
        }
    }
    else if [zimbra_module] == "FileUploadServlet" {
        if "multiline" not in [log][flags] {
		dissect {
			mapping => ["message","%{zimbra_status}: %{zimbra_action}: { accountId=%{zimbra_accountId}, time=%{zimbra_time}, size=%{zimbra_size}, uploadId=%{zimbra_uploadId}, name=%{zimbra_fileName}, path=%{zimbra_path}"]
		}
		mutate { 
			gsub => [ "zimbra_path"," }","" ]
		}
	}
    }
    else if [zimbra_module] == "gal" {
        if "multiline" not in [log][flags] {
		if "autocomplete" in [message] {
	                dissect {
        	                mapping => ["message","%{zimbra_action}: overall=%{zimbra_overall_ms}ms, ranking=%{zimbra_ranking_ms}ms, folder=%{zimbra_folder_ms}ms, gal=%{zimbra_gal_ms}ms"]
                	}
		}
        }
    }
    else if [zimbra_module] == "smtp" {
        if "multiline" not in [log][flags] {
		dissect {
			mapping => ["message","Sending message to MTA at %{zimbra_server}: %{message}"]
		}
                kv {
                    allow_duplicate_values => false
                    field_split => ", "
                    source => "message"
                    prefix => "zimbra_"
                    include_brackets => true
                    add_tag => ["_zimbra_smtp_kv_success"]
                    tag_on_failure => ["_zimbra_smtp_kv_failed"]
                }
		if [zimbra_uploads] {
	                dissect {
        	                mapping => ["zimbra_uploads","%{zimbra_action}: %{message}"]
                	}
        	        kv {
        	            allow_duplicate_values => false
	                    field_split => ","
                	    source => "message"
        	            prefix => "zimbra_upload_"
	                    include_brackets => true
                	    add_tag => ["_zimbra_smtp_kv_success"]
        	            tag_on_failure => ["_zimbra_smtp_kv_failed"]
	                }
		}
        }
    }
    else if [zimbra_module] == "index" {
        if "multiline" not in [log][flags] {
                dissect {
                        mapping => ["message","%{zimbra_action} processed=%{zimbra_processed},failed=%{zimbra_failed},elapsed=%{zimbra_elapsed} (%{zimbra_items_sec} items/sec)"]
                }
	}
    }
    else if [zimbra_module] == "session" {
        if "multiline" not in [log][flags] {
                dissect {
                        mapping => ["message","%{zimbra_status}: "]
                }
        }
    }
    else if [zimbra_module] == "purge" {
        if "multiline" not in [log][flags] {
		if "Purging messages" in [message] {
			mutate {
				gsub => [ "zimbra_action", "\.", "" ]
				rename => ["message", "zimbra_action"]
			}
		}
		else if "Skipping" in [message] {
			dissect {
				mapping => [ "message", "%{zimbra_action} the recently modified/moved folder %{zimbra_folder}" ]
			}
		}
        }
    }
    else if [zimbra_module] == "SessionCache" {
        if "multiline" not in [log][flags] {
                dissect {
                        mapping => ["message","%{zimbra_action} %{zimbra_idleSessions} idle sessions (%{zimbra_interface}). %{zimbra_activeSessions} active sessions remain."]
                }
        }
    }
    else if [zimbra_module] == "AutoDiscoverServlet" {
        if "multiline" not in [log][flags] {
		mutate {
			rename => [ "message", "zimbra_message" ]
		}
        }
    }
    else if [zimbra_module] == "GetCalendarItem" {
        if "multiline" not in [log][flags] {
                mutate {
                        rename => [ "message", "zimbra_message" ]
                }
        }
    }
    else if [zimbra_module] == "filter" {
        if "multiline" not in [log][flags] {
		if "Discarding" in [message] {
			grok {
				match => [ "message", "%{DATA:zimbra_action} with Message-ID <%{DATA:zimbra_messageId}> from (%{DATA:zimbra_fromName} )?((<%{DATA:zimbra_from}>)|%{GREEDYDATA:zimbra_from})" ]
			}
		}
		else if "Disabling" in [message] or "Updating" in [message] {
			grok {
				match => [ "message", "(%{DATA:zimbra_action} rules that reference %{DATA:zimbra_reference} in %{DATA:zimbra_place}\.)|(%{DATA:zimbra_action} rules that reference %{DATA:zimbra_reference}\.)" ]
			}
		}
                else if "Ignoring" in [message] or "Redirecting" in [message] {
			grok {
				match => [ "message", "(%{DATA:zimbra_action} second attempt to file into %{DATA:zimbra_reference}\.$)|(%{DATA:zimbra_action} to %{DATA:zimbra_to}\.$)" ]
			}
		}
		else if "Updated" in [message] {
			dissect {
				mapping => [ "message", "%{zimbra_action} due to folder move or rename from %{zimbra_folderFrom} to %{zimbra_folderTo}." ]
			}
		}
        }
    }
    else if [zimbra_module] == "cache" {
        if "multiline" not in [log][flags] {
                mutate {
                        rename => [ "message", "zimbra_message" ]
                }
        }
    }
    else if [zimbra_module] == "sqltrace" {
        if "multiline" not in [log][flags] {
		dissect {
			mapping => [ "message", "%{zimbra_status} (%{zimbra_query_ms}ms): %{zimbra_queryTrace}" ]
		}
        }
    }
    else if [zimbra_module] == "extensions" {
        if "multiline" not in [log][flags] {
		if "Starting Smart Scan" in [message] {
	                dissect {
        	                mapping => [ "message", "%{zimbra_action} for account %{zimbra_accountId}." ]
			}
                }
		else if "setting config" in [message] {
			dissect {
				mapping => ["message", "%{zimbra_action} entry %{zimbra_config} in %{zimbra_extension}"]
			}
		}
		else if "system failure" in [message] {
			dissect {
				mapping => ["message","%{zimbra_message}: %{zimbra_status}: %{zimbra_reason}"]
			}
		}
                else if "Purged Item" in [message] {
                        dissect {
                                mapping => ["message","Purged Item:%{zimbra_purgedItem} of account id: %{zimbra_accountId}"]
                        }
                }
		else {
                        mutate {
                                rename => ["message", "zimbra_message"]
                        }
		}
        }
    }
    else if [zimbra_module] == "LdapLicenseCounter" {
        if "multiline" not in [log][flags] {
		if "Begin" in [message] {
	                dissect {
        	                mapping => [ "message", "Begin account=%{zimbra_numAccount},archiving=%{zimbra_numArchiving}" ]
                	}
		}
                else if "End" in [message] {
                        dissect {
                                mapping => [ "message", "End account=%{zimbra_numAccount},archiving=%{zimbra_numArchiving},next=%{zimbra_nextCheck_seg}" ]
                        }
                }
        }
    }
    else if [zimbra_module] == "backup" {
        if "multiline" not in [log][flags] {
                if "is started" in [message] {
                        dissect {
                                mapping => [ "message", "%{zimbra_action} is %{zimbra_status} for account %{zimbra_accountBackup}" ]
                        }
                }
                else if "ended" in [message] {
                        dissect {
                                mapping => [ "message", "%{zimbra_action} has %{zimbra_status}" ]
                        }
                }
                else if "file IO" in [message] {
                        grok {
                                match => [ "message", "(Account %{DATA:zimbra_accountBackup} in backup set %{DATA:zimbra_backupSet}: %{DATA:zimbra_message} \(%{DATA:zimbra_backupIOCompleted} out of %{DATA:zimbra_backupIOTotal}\))|(Backup set %{DATA:zimbra_backupSet}: %{DATA:zimbra_message} \(%{DATA:zimbra_backupIOCompleted} out of %{DATA:zimbra_backupIOTotal}\))" ]
                        }
                }
		else {
			mutate {
				rename => ["message", "zimbra_message"]
			}
		}
        }
    }
    else if [zimbra_module] == "ldap" {
	if "multiline" not in [log][flags] {
		mutate {
			rename => ["message", "zimbra_message"]
		}
        }
    }
#    else if [zimbra_module] == "zimlet" {
 #       if "multiline" not in [log][flags] {
#		grok {
#			match => [ "message", "(%{DATA:zimbra_status}: %{GREEDYDATA:zimbra_zimlet})|(cannot find zimlet %{GREEDYDATA:zimbra_zimlet})" ]
#		}
#		if not [zimbra_status] {
#			mutate {
#				add_field => [ "zimbra_status", "Zimlet not found" ]
#			}
#		}
#        }
    }
    
    else if "MTA" in [log][file][path] {
    grok {
        match   => [ "message", "%{SYSLOGBASE} %{GREEDYDATA:message}" ]
        overwrite => [ "message", "timestamp" ]
    }
    date {
        match => [ "timestamp", "MMM dd HH:mm:ss",
                              "MMM  d HH:mm:ss", "ISO8601" ]
        timezone => "Etc/GMT+3"
    }
    # grok log lines by program name (listed alpabetically)
    if [program] =~ /^postfix.*\/anvil$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_ANVIL}$" ]
            tag_on_failure => [ "_grok_postfix_anvil_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/bounce$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_BOUNCE}$" ]
            tag_on_failure => [ "_grok_postfix_bounce_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/cleanup$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_CLEANUP}$" ]
            tag_on_failure => [ "_grok_postfix_cleanup_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/dnsblog$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_DNSBLOG}$" ]
            tag_on_failure => [ "_grok_postfix_dnsblog_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/error$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_ERROR}$" ]
            tag_on_failure => [ "_grok_postfix_error_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/local$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_LOCAL}$" ]
            tag_on_failure => [ "_grok_postfix_local_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/master$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_MASTER}$" ]
            tag_on_failure => [ "_grok_postfix_master_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/pickup$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_PICKUP}$" ]
            tag_on_failure => [ "_grok_postfix_pickup_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/pipe$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_PIPE}$" ]
            tag_on_failure => [ "_grok_postfix_pipe_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/postdrop$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_POSTDROP}$" ]
            tag_on_failure => [ "_grok_postfix_postdrop_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/postscreen$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_POSTSCREEN}$" ]
            tag_on_failure => [ "_grok_postfix_postscreen_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/qmgr$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_QMGR}$" ]
            tag_on_failure => [ "_grok_postfix_qmgr_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/scache$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_SCACHE}$" ]
            tag_on_failure => [ "_grok_postfix_scache_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/sendmail$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_SENDMAIL}$" ]
            tag_on_failure => [ "_grok_postfix_sendmail_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/smtp$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_SMTP}$" ]
            tag_on_failure => [ "_grok_postfix_smtp_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/lmtp$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_LMTP}$" ]
            tag_on_failure => [ "_grok_postfix_lmtp_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/smtpd$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_SMTPD}$" ]
            tag_on_failure => [ "_grok_postfix_smtpd_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/postsuper$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_POSTSUPER}$" ]
            tag_on_failure => [ "_grok_postfix_postsuper_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/tlsmgr$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_TLSMGR}$" ]
            tag_on_failure => [ "_grok_postfix_tlsmgr_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/tlsproxy$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_TLSPROXY}$" ]
            tag_on_failure => [ "_grok_postfix_tlsproxy_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/trivial-rewrite$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_TRIVIAL_REWRITE}$" ]
            tag_on_failure => [ "_grok_postfix_trivial_rewrite_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/discard$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_DISCARD}$" ]
            tag_on_failure => [ "_grok_postfix_discard_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*\/virtual$/ {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => [ "message", "^%{POSTFIX_VIRTUAL}$" ]
            tag_on_failure => [ "_grok_postfix_virtual_nomatch" ]
            add_tag        => [ "_grok_postfix_success" ]
        }
    } else if [program] =~ /^postfix.*/ {
        mutate {
            add_tag => [ "_grok_postfix_program_nomatch" ]
        }
    }

    # process key-value data if it exists
    if [postfix_keyvalue_data] {
        kv {
            source       => "postfix_keyvalue_data"
            trim_value   => "<>,"
            prefix       => "postfix_"
            remove_field => [ "postfix_keyvalue_data" ]
        }

        # some post processing of key-value data
        if [postfix_client] {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match          => ["postfix_client", "^%{POSTFIX_CLIENT_INFO}$"]
                tag_on_failure => [ "_grok_kv_postfix_client_nomatch" ]
                remove_field   => [ "postfix_client" ]
            }
        }
        if [postfix_relay] {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match          => ["postfix_relay", "^%{POSTFIX_RELAY_INFO}$"]
                tag_on_failure => [ "_grok_kv_postfix_relay_nomatch" ]
                remove_field   => [ "postfix_relay" ]
            }
        }
        if [postfix_delays] {
            grok {
                patterns_dir   => "/usr/share/logstash/config/patterns"
                match          => ["postfix_delays", "^%{POSTFIX_DELAYS}$"]
                tag_on_failure => [ "_grok_kv_postfix_delays_nomatch" ]
                remove_field   => [ "postfix_delays" ]
            }
        }
    }

    # process command counter data if it exists
    if [postfix_command_counter_data] {
        grok {
            patterns_dir   => "/usr/share/logstash/config/patterns"
            match          => ["postfix_command_counter_data", "^%{POSTFIX_COMMAND_COUNTER_DATA}$"]
            tag_on_failure => ["_grok_postfix_command_counter_data_nomatch"]
            remove_field   => ["postfix_command_counter_data"]
        }
    }

    # Do some data type conversions
    mutate {
        convert => [
            # list of integer fields
            "postfix_anvil_cache_size", "integer",
            "postfix_anvil_conn_count", "integer",
            "postfix_anvil_conn_rate", "integer",
            "postfix_client_port", "integer",
            "postfix_cmd_auth", "integer",
            "postfix_cmd_auth_accepted", "integer",
            "postfix_cmd_count", "integer",
            "postfix_cmd_count_accepted", "integer",
            "postfix_cmd_data", "integer",
            "postfix_cmd_data_accepted", "integer",
            "postfix_cmd_ehlo", "integer",
            "postfix_cmd_ehlo_accepted", "integer",
            "postfix_cmd_helo", "integer",
            "postfix_cmd_helo_accepted", "integer",
            "postfix_cmd_mail", "integer",
            "postfix_cmd_mail_accepted", "integer",
            "postfix_cmd_quit", "integer",
            "postfix_cmd_quit_accepted", "integer",
            "postfix_cmd_rcpt", "integer",
            "postfix_cmd_rcpt_accepted", "integer",
            "postfix_cmd_rset", "integer",
            "postfix_cmd_rset_accepted", "integer",
            "postfix_cmd_starttls", "integer",
            "postfix_cmd_starttls_accepted", "integer",
            "postfix_cmd_unknown", "integer",
            "postfix_cmd_unknown_accepted", "integer",
            "postfix_nrcpt", "integer",
            "postfix_postscreen_cache_dropped", "integer",
            "postfix_postscreen_cache_retained", "integer",
            "postfix_postscreen_dnsbl_rank", "integer",
            "postfix_relay_port", "integer",
            "postfix_server_port", "integer",
            "postfix_size", "integer",
            "postfix_status_code", "integer",
            "postfix_termination_signal", "integer",

            # list of float fields
            "postfix_delay", "float",
            "postfix_delay_before_qmgr", "float",
            "postfix_delay_conn_setup", "float",
            "postfix_delay_in_qmgr", "float",
            "postfix_delay_transmission", "float",
            "postfix_postscreen_violation_time", "float"
        ]
    }
    }
}
output {
    elasticsearch {
        hosts => [ "http://172.17.0.1:9202" ]
        index => "logstash-logs-%{+YYYY}"
        user => "elastic"
        password => "Bk@tech"
    }
}
